# -*- coding: utf-8 -*-
"""TEAM07_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FXEgILDSbUDTU8j8Wp7zr82Z1jL-_tXI

# Rainfall Prediction In Austrailia

Done by:

*   Hamza Mohammed
*   Norbert Irsik
*   Zhiyuan Li
*   Matthew Palandra

# Import necessary Modules
"""

import collections
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import StandardScaler

import time
import csv
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torchvision
from torchvision import datasets, transforms

from torch.utils.data.sampler import SubsetRandomSampler
from torch.utils.data import Dataset, DataLoader

import torchvision.transforms as transforms

from sklearn.svm import SVC
from sklearn import metrics
import matplotlib.pyplot as plt
from sklearn.inspection import DecisionBoundaryDisplay
from sklearn.decomposition import PCA


device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(device)

"""# Load and Process Data"""

# first mount your google drive into the notebook
from google.colab import drive
drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# next go to your kaggle account settings and click create new token under API
# a file called kaggle.json will download. Upload this into your google drive and run this code
# /content/gdrive/My Drive/Kaggle is the path where kaggle.json is present in the Google Drive

import os
os.environ['KAGGLE_CONFIG_DIR'] = "/content/gdrive/My Drive/Kaggle"

#changing the working directory
# %cd /content/gdrive/My Drive/Kaggle

#donwnload the dataset using this command
!kaggle datasets download -d jsphyg/weather-dataset-rattle-package

#unzipping the zip files and deleting the zip files
!unzip \*.zip  && rm *.zip

# reading the csv file
weather_data = pd.read_csv('weatherAUS.csv',delimiter = ',', encoding = "UTF-8")

#taking a look at the data
weather_data.head(5)

"""### Dropping Null Values"""

null_count = weather_data['RainTomorrow'].isnull().sum()
print(f'The are {null_count} nan variables in our target column')

weather_data = weather_data.dropna(subset=['RainTomorrow'])
print(f'Now there are {weather_data.RainTomorrow.isnull().sum()} nan variables in our target column')

"""### Transforming 'Date' column to DateTime"""

weather_data['Date'] = pd.to_datetime(weather_data['Date'])

"""# Feature Analysis

### Feature Visualization for Sydney
"""

feature_keys = [
    'MinTemp',
    'MaxTemp',
    'Rainfall',
    'Evaporation',
    'Sunshine',
    'WindGustSpeed',
    'WindSpeed9am',
    'WindSpeed3pm',
    'Humidity9am',
    'Humidity3pm',
    'Pressure9am',
    'Pressure3pm',
    'Cloud9am',
    'Cloud3pm',
    'Temp9am',
    'Temp3pm'
]

colors = [
    "blue",
    "orange",
    "green",
    "red",
    "purple",
    "brown",
    "pink",
    "gray",
    "olive",
    "cyan",
    '#c53edf',
    '#d75528',
    '#14ba5e',
    '#8490bc',
    '#f8cb83',
    '#cf5386',
    '#9b4bce'
]

def show_raw_visualization(data):
    time_data = data['Date']
    fig, axes = plt.subplots(
        nrows=8, ncols=2, figsize=(15, 20), dpi=80, facecolor="w", edgecolor="k"
    )
    for i in range(len(feature_keys)):
        key = feature_keys[i]
        c = colors[i % (len(colors))]
        t_data = data[key]
        t_data.index = time_data
        t_data.head()
        ax = t_data.plot(
            ax=axes[i // 2, i % 2],
            color=c,
            title="{} - {}".format(feature_keys[i], key),
            rot=25,
        )
        ax.legend([feature_keys[i]], loc='lower right')

        # Dynamically set y-axis limits
        ymin, ymax = t_data.min(), t_data.max()
        yrange = ymax - ymin
        ax.set_ylim(ymin - 0.1 * yrange, ymax + 0.1 * yrange)  # Adjust 0.1 to increase/decrease the buffer

    plt.tight_layout()

show_raw_visualization(weather_data[weather_data['Location'] == 'Sydney'])

"""### Correlation Analysis
Correlation analysis is important for non neural networks becuase unlike ANNs, they cannot find out on their own if features are correlated and important. So,we will not remove correlated features out of the training loop for our neural network, only for our non-neural baseline model (SVM).
"""

correlation = weather_data.corr()

plt.figure(figsize=(18,12))
plt.title('Correlation Heatmap of Rain in Australia Dataset')
ax = sns.heatmap(correlation, square=True, annot=True, fmt='.2f', linecolor='white')
ax.set_xticklabels(ax.get_xticklabels(), rotation=90)
ax.set_yticklabels(ax.get_yticklabels(), rotation=30)
plt.show()

"""### Outlier Analysis"""

def outlier_plot(data):
    # draw boxplots to visualize outliers
    plt.figure(figsize=(15,10))

    plt.subplot(2, 2, 1)
    fig = data.boxplot(column='Evaporation')
    fig.set_title('')
    fig.set_ylabel('Evaporation')


    plt.subplot(2, 2, 2)
    fig = data.boxplot(column='WindSpeed9am')
    fig.set_title('')
    fig.set_ylabel('WindSpeed9am')


    plt.subplot(2, 2, 3)
    fig = data.boxplot(column='WindSpeed3pm')
    fig.set_title('')
    fig.set_ylabel('WindSpeed3pm')

outlier_plot(weather_data)

"""# Pre-Split Feature Engineering"""

columns_to_remove = []

def pre_split_feature_engineering(data, impute_outliers=True, remove_correlated=False):

    def numerical_feat_eng(data, correlation_threshold=0.9):
        numerical_columns = [var for var in data.columns if data[var].dtype!='O']

        # filling nan with median of the respective column
        for col in numerical_columns:
            try:
                col_median = data[col].median()
                data[col].fillna(col_median, inplace=True)
            except:
                pass


        if impute_outliers:
            lower_lim_list = []
            upper_lim_list = []
            outlier_dic = dict()

            # Columns with outliers
            contain_outliers = ['Evaporation', 'WindSpeed9am' , 'WindSpeed3pm']

            for col in contain_outliers:
                IQR = data[col].quantile(0.75) - data[col].quantile(0.25)
                Lower_lim = data[col].quantile(0.25) - (IQR * 1.5)
                Upper_lim = data[col].quantile(0.75) + (IQR * 1.5)

                print('Outliers in {name} are < {lowerboundary:.2f} or > {upperboundary:.3f}'.format(name = col, lowerboundary=Lower_lim, upperboundary=Upper_lim))
                #print('# of outliers: {:.2f} % \n ----'.format(data[data[col] > Upper_lim].shape[0]/data[col].shape[0]*100))
                outlier_dic[col] = [Lower_lim, Upper_lim]

            # imputting outliers
            for name, lim_list in outlier_dic.items():
                lower_lim, upper_lim = lim_list[0], lim_list[1]
                data[name] = np.where(data[name]>upper_lim, upper_lim, data[name])
                data[name] = np.where(data[name]<lower_lim, lower_lim, data[name])


        if remove_correlated:
            # Calculate correlation matrix
            corr_matrix = data[numerical_columns].corr().abs()
            upper_tri = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))

            # Identify columns to remove (any one of each pair of correlated features)
            for column in upper_tri.columns:
                if any(upper_tri[column] > correlation_threshold):
                    columns_to_remove.append(column)

            # Remove correlated columns
            data = data.drop(columns=columns_to_remove)

        return data

    def categorical_feat_eng(data):
        categorical_columns = [var for var in data.columns if data[var].dtype=='O']

        # For all the wind directions columns, we will assume that
        # nan values are 0 wind speed values, and nan for 'Rain Today' is a No.
        for column in categorical_columns:
            # Replacing all wind direction column nans with 0
            if 'Dir' in column:
                data[column].fillna('NoWind', inplace=True)
            elif 'RainToday' in column:
                data[column].fillna('No', inplace=True)

        # replacing categorical target varibales
        data['RainToday'].replace({'Yes': 1, 'No': 0}, inplace=True)
        data['RainTomorrow'].replace({'Yes': 1, 'No': 0}, inplace=True)

        data = pd.concat([
            data,
            pd.get_dummies(data.Location),
            pd.get_dummies(data.WindGustDir),
            pd.get_dummies(data.WindDir9am),
            pd.get_dummies(data.WindDir3pm)], axis=1)

        # Dropping encoded columns
        data = data.drop(columns=['WindGustDir',
                                  'WindDir9am',
                                  'WindDir3pm',
                                  'Location'
                                 ])

        return data

    data = numerical_feat_eng(data)

    data = categorical_feat_eng(data)

    return data

SVM_weather_data = pre_split_feature_engineering(weather_data, impute_outliers=True, remove_correlated=True).drop(columns=['Date'])
outlier_plot(SVM_weather_data)

"""# Baseline Model (SVM)

### Train Validation Test Split
"""

train_proportions = 0.8
val_proportions = 0.1
test_proportions = 0.1

# Split the subset by rating to create new train, val, and test splits
by_rain_tmr = collections.defaultdict(list)
for _, row in SVM_weather_data.iterrows():
    by_rain_tmr[row['RainTomorrow']].append(row.to_dict())

# Create split data
final_list = list()
np.random.seed(1000)

for _, rain_tomorrow in sorted (by_rain_tmr.items()):
    np.random.shuffle(rain_tomorrow)

    n_total = len(rain_tomorrow)
    n_train = int(train_proportions * n_total)
    n_val = int(val_proportions * n_total)
    n_test = int(test_proportions * n_total)

    # Give data point a split attribute
    for text in rain_tomorrow[:n_train]:
        text['split'] = 'train'

    for text in rain_tomorrow[n_train:n_train+n_val]:
        text['split'] = 'val'

    for text in rain_tomorrow[n_train+n_val:n_train+n_val+n_test]:
        text['split'] = 'test'

    final_list.extend(rain_tomorrow)

SVM_data = pd.DataFrame(final_list)

SVM_data['split'].value_counts()

"""### Training SVM"""

train_SVM = SVM_data[SVM_data['split'] == 'train'].drop(['split'], axis=1)
val_SVM = SVM_data[SVM_data['split'] == 'val'].drop(['split'], axis=1)
test_SVM = SVM_data[SVM_data['split'] == 'test'].drop(['split'], axis=1)

y_train_SVM = train_SVM['RainTomorrow']
y_val_SVM = val_SVM['RainTomorrow']
y_test_SVM = test_SVM['RainTomorrow']


pca = PCA(n_components=2)
X_2d_train = pca.fit_transform(train_SVM)
X_2d_val = pca.transform(val_SVM)


# Create SVM Classifier with a linear kernel
clf = SVC(kernel='rbf')

# Train the model using the training sets
clf.fit(X_2d_train, y_train_SVM)

# Predict the response for test dataset
y_pred = clf.predict(X_2d_val)

# Check accuracy
print("Accuracy:", metrics.accuracy_score(y_test_SVM, y_pred))

"""### SVM Boundary Visualization"""

DecisionBoundaryDisplay.from_estimator(
    clf,
    X_2d_train,
    response_method="predict",
    cmap=plt.cm.Spectral,
    alpha=0.8,
)

# Scatter plot for the training data
plt.scatter(X_2d_train[:, 0], X_2d_train[:, 1], c=y_train_SVM, s=20, edgecolors="k")

# Add some labels for clarity
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.title('Decision Boundary with the first two Principal Components')

plt.show()

"""#Neural Network"""

NN_weather_data = pre_split_feature_engineering(weather_data, impute_outliers=True, remove_correlated=False)

"""### Data Splitting"""

def stratified_split_by_year(data, target_column, train_proportion=0.8, val_proportion=0.1):
    """
    Splits the data into training, validation, and test sets by year and month,
    ensuring proportional representation of the target variable in each set.

    :param data: Pandas DataFrame containing the weather data.
    :param train_proportion: Proportion of data to be used for training.
    :param val_proportion: Proportion of data to be used for validation.
    :param target_column: The name of the column containing the target variable.
    :return: Three DataFrames corresponding to the training, validation, and test sets.
    """
    # Extract year, month, and day from the date
    data['Year'] = pd.to_datetime(data['Date']).dt.year
    data['Month'] = pd.to_datetime(data['Date']).dt.month
    data['Day'] = pd.to_datetime(data['Date']).dt.day

    years = data['Year'].unique()
    np.random.shuffle(years)

    # Initialize empty lists for train, val, and test
    train_list = []
    val_list = []
    test_list = []

    # Split data within each year
    for year in years:
        year_data = data[data['Year'] == year]

        months = year_data['Month'].unique()
        np.random.shuffle(months)  # Shuffle months within the year

        for month in months:
            month_data = year_data[year_data['Month'] == month]
            days = month_data['Day'].unique().tolist()

            n_total = len(days)
            n_train = int(train_proportion * n_total)
            n_val = int(val_proportion * n_total)
            n_test = n_total - n_train - n_val

            train_days = days[:n_train]
            val_days = days[n_train:n_train + n_val]
            test_days = days[n_train + n_val:]

            if 31 in test_days:
                test_days.remove(31)

            # Combine the splits
            train_list.append(month_data[month_data['Day'].isin(train_days)])
            val_list.append(month_data[month_data['Day'].isin(val_days)])
            test_list.append(month_data[month_data['Day'].isin(test_days)])


    train_df = pd.concat(train_list, ignore_index=True)
    val_df = pd.concat(val_list, ignore_index=True)
    test_df = pd.concat(test_list, ignore_index=True)

    train_df.drop(['Date', 'Year', 'Month', 'Day'], axis=1, inplace=True)
    val_df.drop(['Date', 'Year', 'Month', 'Day'], axis=1, inplace=True)
    test_df.drop(['Date', 'Year', 'Month', 'Day'], axis=1, inplace=True)


    return train_df, val_df, test_df

# Splits
train_proportion = 0.8
val_proportion = 0.1
target_column = 'RainTomorrow'
# Assuming 'weather_data' is your DataFrame
train_data, val_data, test_data = stratified_split_by_year(NN_weather_data, target_column, train_proportion, val_proportion)

print('################ Train Data ################')
print(train_data.RainTomorrow.value_counts())
print('\n')

print('################ Val Data ################')
print(val_data.RainTomorrow.value_counts())
print('\n')

print('################ Test Data ################')
print(test_data.RainTomorrow.value_counts())
print('\n')

"""### Post-Split NN Feature Engineering"""

def post_feature_engineering(data, set_type, scaler):

    if set_type=='Train':
        data[feature_keys] = scaler.fit_transform(data[feature_keys])
    else:
        data[feature_keys] = scaler.transform(data[feature_keys])

    return data

"""### Sequence and Batch Function"""

class TimeSeriesDataset(Dataset):
    def __init__(self, data, labels, sequence_length, num_locations):
        """
        data: Your feature data including location one-hot encodings.
        labels: Your target data.
        sequence_length: The length of the input sequence.
        num_locations: Number of unique locations in your dataset.
        """
        self.data = data
        self.labels = labels
        self.sequence_length = sequence_length
        self.num_locations = num_locations

    def __len__(self):
        # Adjusted to ensure there's a target available for every sequence at each location
        return (len(self.data) - self.sequence_length -1) // self.num_locations

    def __getitem__(self, index):
        """
        Returns a batch of parallel sequences from each location and their corresponding targets.
        """
        x = []
        y = []

        for loc in range(self.num_locations):
            loc_index = index + loc * self.__len__()
            x.append(self.data[loc_index:loc_index + self.sequence_length])
            # The target is the 'RainTomorrow' value on the third day of the sequence
            y.append(self.labels[loc_index + self.sequence_length - 1])

        x = torch.stack(x)
        y = torch.stack(y)

        return x, y



def get_loader(data, batch_size, set_type, unique_locations, scaler):
    # Example usage
    sequence_length = 3  # Two days for each input sequence

    data = post_feature_engineering(data, set_type, scaler)


    X = data.drop(columns=['RainTomorrow']).to_numpy().astype(float)
    y = data["RainTomorrow"].to_numpy()

    # Assuming x_train and y_train are your data and labels
    X_tensor = torch.tensor(X).float()
    y_tensor = torch.tensor(y).float()

    # Create the dataset and data loader
    dataset = TimeSeriesDataset(X_tensor, y_tensor, sequence_length, unique_locations)
    dataloader = DataLoader(dataset, batch_size=batch_size)

    return dataloader

"""### Data Overview Visual - Matt"""

#given that 'weather_data_clean' is our pre processed DataFrame
weather_data_clean=pre_split_feature_engineering(weather_data) #preprocessing function

#calc summary stats fr key columns
summary_stats=weather_data_clean[feature_keys].describe()

#print summary statistics
print("Summary Statistics for Key Features:")
print(summary_stats)

#print number of rows and columns
print("\nNumber of Rows:", weather_data_clean.shape[0])
print("\nNumber of Columns:", weather_data_clean.shape[1])

#Display the first few rows of preprocessed data
print("\nExample of Preprocessed Data Points:")
print(weather_data_clean.head())

"""## Defining Training Functions"""

###############################################################################
# Training
def get_model_name(name, batch_size, learning_rate, epoch):
    """ Generate a name for the model consisting of all the hyperparameter values

    Args:
        config: Configuration object containing the hyperparameters
    Returns:
        path: A string with the hyperparameter name and value concatenated
    """
    path = "model_{0}_bs{1}_lr{2}_epoch{3}".format(name,
                                                           batch_size,
                                                           learning_rate,
                                                           epoch)
    return path

def get_accuracy(net, loader, criterion, mode='accuracy'):
    """ Evaluate the network on a specific data loader.

     Args:
         net: PyTorch neural network object
         loader: PyTorch data loader
         criterion: The loss function
     Returns:
         acc: A scalar for the avg classification error over the loader
         loss: A scalar for the average loss function over the loader
     """
    total_acc = 0.0
    total_loss = 0.0
    total_in_epoch = 0.0
    prediction_list = []

    with torch.no_grad():
        for i, (inputs, labels) in enumerate(loader):
            inputs = inputs.to(device)
            labels = labels.to(device)

            outputs = net(inputs)
            loss = criterion(outputs, labels)
            predictions = (outputs > 0.5).float()
            prediction_list.append(predictions.cpu().numpy())  # Assuming you want NumPy arrays

            total_acc += (predictions == labels).sum().item()
            total_loss += loss.item()
            total_in_epoch += labels.numel()  # Assuming labels is a 1D tensor

    if mode == 'prediction':
        return prediction_list
    else:
        if total_in_epoch > 0:
            acc = float(total_acc) / total_in_epoch
            loss = float(total_loss) / (i + 1)
        else:
            acc = 0.0
            loss = 0.0
        return acc, loss

def plot_training_curve(path):
    """ Plots the training curve for a model run, given the csv files
    containing the train/validation error/loss.

    Args:
        path: The base path of the csv files produced during training
    """
    train_acc = np.loadtxt(f'{path}_train_acc.csv')
    val_acc = np.loadtxt(f'{path}_val_acc.csv')
    train_loss = np.loadtxt(f'{path}_train_loss.csv')
    val_loss = np.loadtxt(f'{path}_val_loss.csv')
    plt.title('Train vs Validation Accuracy')
    n_epochs = len(train_acc)
    plt.plot(range(1, n_epochs+1), train_acc, label='Training')
    plt.plot(range(1, n_epochs+1), val_acc, label='Validation')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.legend(loc='best')
    plt.show()
    plt.title('Train vs Validation Loss')
    plt.plot(range(1, n_epochs+1), train_loss, label='Training')
    plt.plot(range(1, n_epochs+1), val_loss, label='Validation')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend(loc='best')
    plt.show()


def train_RNN(net, train_loader, val_loader, verbose=False,  learning_rate=0.01, num_epochs=30, batch_size=64):
    ########################################################################
    # Fixed PyTorch random seed for reproducible result
    torch.manual_seed(1000)
    ########################################################################
    # Define the Loss function and optimizer
    criterion = nn.BCEWithLogitsLoss()
    optimizer = optim.SGD(net.parameters(), lr=learning_rate, momentum=0.9)
    ########################################################################
    # Set up some numpy arrays to store the training/test loss/acrruracy
    train_acc = np.zeros(num_epochs)
    train_loss = np.zeros(num_epochs)
    val_acc = np.zeros(num_epochs)
    val_loss = np.zeros(num_epochs)
    # Train the network
    # Loop over the data iterator and sample a new batch of training data
    # Get the output from the network, and optimize our loss function.
    start_time = time.time()
    for epoch in range(num_epochs):
        total_train_loss = 0.0
        total_train_acc = 0.0
        total_in_epoch = 0
        for i, (inputs, labels) in enumerate(train_loader):
            inputs = inputs.to(device)
            labels = labels.to(device)
            # Handling variable batch sizes
            #input_batch_size, _, seq_length, num_features = inputs.shape
            #inputs = inputs.view(input_batch_size, seq_length, -1)

            # Zero the parameter gradients
            optimizer.zero_grad()
            # Forward pass, backward pass, and optimize
            outputs = net(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            # Calculate the statistics
            predictions = (outputs > 0.5).float()
            total_train_acc += (predictions == labels).sum().item()
            total_train_loss += loss.item()
            total_in_epoch += labels.shape[0] * labels.shape[1]
        # Calculating error and loss for respective epoch
        train_acc[epoch] = float(total_train_acc) / total_in_epoch
        train_loss[epoch] = float(total_train_loss) / (i+1)
        val_acc[epoch], val_loss[epoch] = get_accuracy(net, val_loader, criterion)
        if verbose == True:
            print(("Epoch {}: Train acc: {:.4f}, Train loss: {:.4f} |"+
                   "Validation acc: {:.4f}, Validation loss: {:.4f}").format(epoch + 1,
                                                                   train_acc[epoch],
                                                                   train_loss[epoch],
                                                                   val_acc[epoch],
                                                                   val_loss[epoch]))
        # Save the current model (checkpoint) to a file
        model_path = get_model_name(net.name, batch_size, learning_rate, epoch)
        torch.save(net.state_dict(), model_path)
    print('Finished Training')
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f'Total time elapsed: {elapsed_time:.2f} seconds')
    # Write the train/test loss/err into CSV file for plotting later
    epochs = np.arange(1, num_epochs+1)
    np.savetxt(f'{model_path}_train_acc.csv', train_acc)
    np.savetxt(f'{model_path}_train_loss.csv', train_loss)
    np.savetxt(f'{model_path}_val_acc.csv', val_acc)
    np.savetxt(f'{model_path}_val_loss.csv', val_loss)

"""## Defining the Model"""

class Model(nn.Module):
    def __init__(self, input_size, hidden_dim, output_dim, num_layers, rnn_type='RNN'):
        super().__init__()
        self.rnn_type = rnn_type
        self.num_layers = num_layers

        self.name = f'{self.rnn_type}_{self.num_layers}layers'

        self.hidden_dim = hidden_dim
        self.num_layers = num_layers

        if rnn_type == 'LSTM':
            self.rnn = nn.LSTM(input_size, hidden_dim, num_layers, batch_first=True)
        elif rnn_type == 'GRU':
            self.rnn = nn.GRU(input_size, hidden_dim, num_layers, batch_first=True)
        else:
            self.rnn = nn.RNN(input_size, hidden_dim, num_layers, batch_first=True)

        self.fc = nn.Linear(hidden_dim, output_dim)

    def forward(self, x):
        # x is of shape [batch_size, num_locations, seq_length, num_features]
        batch_size, num_locations, seq_length, num_features = x.shape

        # Process each location independently
        location_outputs = []

        for i in range(num_locations):
            # Extract the sequences for the current location across the whole batch
            location_seq = x[:, i, :, :]  # Shape: [batch_size, seq_length, num_features]

            # Initialize hidden and cell states for the current location
            h0 = torch.zeros(self.num_layers, location_seq.size(0), self.hidden_dim).to(x.device)
            c0 = torch.zeros(self.num_layers, location_seq.size(0), self.hidden_dim).to(x.device)

            # Forward pass through RNN
            if self.rnn_type == 'LSTM':
                location_output, _ = self.rnn(location_seq, (h0, c0))
            else:
                location_output, _ = self.rnn(location_seq, h0)

            # Only take the output from the final timestep for each location
            location_output = self.fc(location_output[:, -1, :])  # Shape: [batch_size, output_dim]
            location_outputs.append(location_output)

        # Concatenate the outputs for each location to get the final output
        final_output = torch.cat(location_outputs, dim=1)  # Shape: [batch_size, num_locations * output_dim]

        return final_output

"""## Training the model"""

scaler = StandardScaler()
BATCH_SIZE = 128
unique_locations = len(weather_data['Location'].unique())x

# Data loaders
train_loader = get_loader(train_data, BATCH_SIZE, 'Train', unique_locations, scaler)
val_loader = get_loader(val_data, BATCH_SIZE, 'Val', unique_locations, scaler)
test_loader = get_loader(test_data, BATCH_SIZE, 'Test', unique_locations, scaler)

# Model instantiation
VERBOSE = True
LEARNING_RATE = 0.1
NUM_EPOCHS = 100

# Model Hyperparameters
INPUT_SIZE = 117  # Number of features in your input
HIDDEN_DIM = 10  # Example value, can be changed
OUTPUT_DIM = 1  # For binary classification, change if needed
MODEL_TYPE = 'RNN'
NUM_LAYERS = 1

model = Model(INPUT_SIZE, HIDDEN_DIM, OUTPUT_DIM, NUM_LAYERS, MODEL_TYPE).to(device)

train_RNN(model, train_loader, val_loader, VERBOSE, LEARNING_RATE, NUM_EPOCHS, BATCH_SIZE)

model_path = get_model_name(f'{MODEL_TYPE}_{NUM_LAYERS}layers', BATCH_SIZE, LEARNING_RATE, (NUM_EPOCHS-1))
plot_training_curve(model_path)



"""## Tuning the HyperParameters

-These calculations wer eperformed on a seprate colab because it is a very time consuming and extensive task. But the follwoing is the loop used to test variosu hyperparamter combiantions and the output graphs.

***To see the FULL hyperparamter tuning check the "Tuning the HyperParameters" section in this colab***: https://colab.research.google.com/drive/1xV53feGhfHIceOp3Z_Rzx_4e0HdT5z-9?usp=sharing


The following is a justificaiton for which hyperparameters will be looked at:

**Batch Size [32,64]**
- we will test a small batch size of 32,given it mayhave better generalization. 64 is also a balance for computational efficiency and model performance. Btahc size is importnat to test because it affects the speed and stabiliting of the training process. We did not not extensively test batch sizes over 128 because smaller sizes provide regularizing andf lower generalizaiton error.

**Learning Rate [0.01, 0.001]**
- Learning rate is curcial to look at, becauyse if it's too large the trainign may nto converge, and if too low, the trianing is slow. 0.01 will be tested for faster convergence, and 0.001 will be tested foer more stable convergence if 0.01 is too aggressive

**RNN Type [LSTM, GRU]**
- Swithcing between RNN, LSTM, and GRU wiol be benficial, as LSTm and GRU are better at cpaturigng long-term dependencies and may give better results for time-series data like weather forecasting

**Number of Layers [1,2]**
- Increasing the number of layers can allow the model to leanr more complex patterns but this raisies the risk of overfitting. 1 layer will be stedt for a simpler model, and 2 layers can capture mroe comple xmodels without gretaly increasing the risk for overfitting.

The following is the trianing loop I ran to get 16 variations
"""

import itertools

scaler = StandardScaler()
unique_locations = len(weather_data['Location'].unique())


#updated hyperparameters to tune
batch_sizes=[32,64]
learning_rates=[0.01,0.001]
rnn_types=['LSTM','GRU']
num_layers_options=[1,2]

#now we do cartesian product of all hyperparmater options
hyperparam_combinations=list(itertools.product(batch_sizes, learning_rates,rnn_types, num_layers_options))

#iterate over all combinations
for batch_size,learning_rate, rnn_type, num_layers in hyperparam_combinations:
  model=Model(INPUT_SIZE, HIDDEN_DIM, OUTPUT_DIM, num_layers, rnn_type).to(device)
  train_loader=get_loader(train_data, batch_size, 'Train',unique_locations, scaler)
  val_loader=get_loader(val_data, batch_size, 'Val', unique_locations,scaler)

  #now calk training functions
  train_RNN(model, train_loader, val_loader, VERBOSE, learning_rate, NUM_EPOCHS, batch_size)

  #save and plot
  model_path=get_model_name(f'{rnn_type}_{num_layers}layers',batch_size,learning_rate, (NUM_EPOCHS-1))
  plot_training_curve(model_path)

"""Again to see the full output visit the "Tuning the Hyperparameters" section here: https://colab.research.google.com/drive/1xV53feGhfHIceOp3Z_Rzx_4e0HdT5z-9#scrollTo=fzIdQC5sSzpL&uniqifier=1

After testing the best hyper parameter output was that the default hyper parameters were best:

LEARNING_RATE = 0.1

NUM_EPOCHS = 100

INPUT_SIZE = 117  # Number of features in your input

HIDDEN_DIM = 10  # Example value, can be changed

OUTPUT_DIM = 1  # For binary classification, change if needed

MODEL_TYPE = 'RNN'

NUM_LAYERS = 1

The closest was giving the output of "Graph 4: batch_size = 32, learning_rate = 0.01, rnn_type = 'GRU', num_layers = 2"

Which resulted in slightly less overfitting but a lower accuracy too seen below. But overall the best hyperparameters were still
![image.png](data:image/png;base64,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T8tRfv/99+nTp9ceeciQIQkJCf7+/rVH08NdOnE0XSuYBOxCWTjUy82FvwyaDixTIgESMBGArggSGzZsWLBgwcmTJ8Wpj095lw88+uBy4uJS44s9JEReZqH2w83NDR7ttcfRyV2+Z5uoIeBDb5rFfKEsjANgTcSUyZAACVQiAF0RB8wjmGIifOLECV9f32+//bZ///7u7u47duw4e/bsHXfcERYWBmG76qqrfvzxRyUVdRciUvi///u/u+66Cw4UHTt2/Oqrr0Q0dRfiBx98gBla3333XdeuXZHaLbfcoohoSUnJk08+ibtwznzuuecmTZp05513KhlZJ0ABayLO8jr0+UZJ9qHnKohNxJTJkIAeCcjzlopKNPpD4g2r8+zZs1966aXjx4/36tUrJydn1KhR27Zt++OPPyA5o0ePjomJqTbZRYsW3X///YcPH0b8Bx98MC0trWo0TNL65z//+eGHH/76669I59lnnxVxXn755Y8//vj999//7bffsrKyvvjii6rPan2lRkuzCTNetWrVq6++ipmAvXv3fuuttwYOHGiW+PXXX//LL7+oL4Lm5s2bcQUtgYYBmtTU1LZt20LwZ8yYoY6pl3DiUZQkzjW6pMClPTdi1kursBwk0PQE8otLuy34runTNaX454sjMQLRgMRffPHFm2++WTwYGBiIl60IL168eNOmTbCuHn/88arJTp48edy4cbi+dOnSN998c+/evRA8s2hwbV+zZk379u1xHYkgIxEBL/M5c+bAgMPpypUrt2zZYvagFU41t8DQVztr1qyFCxceOHAATEeOHClmXKvrtnHjRpil4jh69Cgmst13330iAp7dunXrRx99hF8WTz31FPApdq46heYPJx5BGY4ZW+OTy3A0f3OwBCTgYAQGDBig1Bi/+2EnodMP/Xvo98PLsyYLDOaaeMrb29vPz6/qyxl30cEo1AthrJQh4mRmZiYlJSnWCF7a6MBUCmC1QEOkvl6FW758+bRp06ZMmYKnIOOwq9auXQujSp0Ifi8op+vXrwcvRcB27tyJrlWYaIgA55l33nkHvxHGjBmjxNdLIPEQSrKvsCU+2YWol0ZhOUhAAwKers6wkzRIWE4SiTcsZSiQ8iDU64cffkC/X4cOHbDIxb333ltUVKTcVQewiq5yiiExI8byqxxmcRrcyVkl4Sa4oK0FBmr79+8f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)

![image.png](data:image/png;base64,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wJrc2B0qVHNgIxIUiB8U7Mailow9kLCRDS6xvjukC/aWSPr666+x0ZTY0wfb+2Kxc/UWNYCi5syZIy6Fofbtt9+qqQyQgPsS4LiXG//lwap7AIELL7wQZpP6ItHR0SKM3dTUSISxPSYuYYENGDAAYieSsG8kdqPAviToaczOzsYeJeot2kD//v3FJW7EzhTa/W212RgmAfciQPVyr/ZibT2NABRF28vXutfDMJiNG7EltJoKnYPgqZcMkID7EuC4l/u2HWvuyQSwUar6egj36tULlzhjJAyjXyLpl19+Qc9hjx49wsPDU1JSVq9erd7CAAl4PAHaXh7fxHxBlyaAbXkxcKVW0d/fHzvN4xJOGYMHDx45cuT777+fkZHxxhtvIBI+F4888ghGyx599NFTp07dddddU6ZMwdbGSEIMhsri4uLgqYgtayFsSFWLZYAEPI8A1cvz2pRv5E4EVq5cCQd3tcYwpPbs2YNLOAp+9NFHd9xxB1I//PDD3r17IxJe79999x22pR8yZAjCcEpcuHChuBeSVlVV9cILL9x3333Qv2uvvVYtkwES8EgCPnA48cgX40uRgPsSwOjU559/PnHiRPd9BdacBPQmwHEvvQmzfBIgARIgAccToHo5nilLJAESIAES0JsAew71JszySYAESIAEHE+AtpfjmbJEEiABEiABvQlQvfQmzPJJgARIgAQcT4Dq5XimLJEESIAESEBvAlQvvQmzfBIgARIgAccToHo5nilLJAESIAES0JsA1UtvwiyfBEiABEjA8QSoXo5nyhJJgARIgAT0JkD10pswyycBEiABEnA8AaqX45myRBIgARIgAb0J/D9k5zF3zt2/cgAAAABJRU5ErkJggg==)

## Evaluating on Test Data
"""

acc, loss = get_accuracy(model, test_loader, criterion, mode='accuracy')

print(f'The final accuracy on the Test Data is: {(acc)*100:.2f}%')

"""# Evaluating the Model on New Data

## Obtaining the Data
"""

# This is the data obtained from http://www.bom.gov.au/climate/dwo/IDCJDW2125.latest.shtml on the weather in Sydney Airport

# this is a prediction for the 10th of November, 2023 when it rained.
# this is an example for where it does rain tomorrow so the prediction should be true

# We will be using the data from the 7th , 8th and 9th of November,2023 to predict this rain on the 10th

#7th
new_data_rain_1 = [ 15.3,	24.9,	0,	5.2,	11.6 ,56, 13, 33,60,51, 1023.3, 1019.2,4,5,20.4,23.9, 0, 0,
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0]

#8th
new_data_rain_2 = [16.3,	27,	0,	7.4,	10.7 ,50, 13, 37,62,53, 1019.6, 1015.9,5,5,23.4,25.1, 0, 0,
                   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

#9th
new_data_rain_3 = [ 17.5,	27.6,	0,	8.6,	5.8 ,63, 15, 39,69,61, 1017.0, 1013.5,5,5,22.8,23.8, 0, 1,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]



# this is a prediction for the 15th of November, 2023 when it did not rain.
# this is an example for where it does not rain tomorrow so the prediction should be false

# We will be using the data from the 12th , 13th and 14th of November,2023 to predict this no rain on the 15th

#12th
new_data_no_rain_1 = [18.2,	24.6,	0,	11.0,	7.9 ,63, 20, 19,75,72, 1016.7, 1012.8,2,7,20.2,22.1, 0, 0,
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
#13th
new_data_no_rain_2 = [17.0,	22.9,	0.4,	6.4,	6.3 ,50, 28, 24,74,51, 1019.2, 1017.1,7,6,18.9,22.0, 0, 0,
                       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]

#14th
new_data_no_rain_3 = [17.9,	25.5,	0,	8.0,	9.5 ,39, 15, 31,62,61, 1014.9, 1012.1,3,5,21.4,23.9, 0, 0,
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                     0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

# This is the data obtained from http://www.bom.gov.au/climate/dwo/IDCJDW2125.latest.shtml on the weather in Brisbane

# this is a prediction for the 21th of November, 2023 when it rained.
# this is an example for where it does rain tomorrow so the prediction should be true

# We will be using the data from the 18nd , 19rd and 20th of November,2023 to predict this rain on the 25th


#18th
new_data_rain_bris_1 = [ 18.2,	26.9,	0,	9.6,	12.7 ,31, 7, 15,46,38, 1021, 1018.7,7,1,23.6,25.4, 0, 0,
                         0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

#19th
new_data_rain_bris_2 = [ 16.8,	28.6,	0,	9.4,	9.6 ,26, 7, 13,51,55, 1022.3, 1019.9,6,7,25.5,25.3, 0, 1,
                        0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

#20th
new_data_rain_bris_3 = [ 20.3,	23.2,	4.8,	7.6,	0.0 ,24, 6, 7,72,68, 1020.9, 1019.0,8,8,23.3,22.3, 1, 1,
                        0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0]






new_data_rain_1 = [ 15.3,	24.9,	0,	5.2,	11.6 ,56, 13, 33,60,51, 1023.3, 1019.2,4,5,20.4,23.9, 0, 0,
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0]


new_data_rain_2 = [16.3,	27,	0,	7.4,	10.7 ,50, 13, 37,62,53, 1019.6, 1015.9,5,5,23.4,25.1, 0, 0,
                   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]


new_data_rain_3 = [ 17.5,	27.6,	0,	8.6,	5.8 ,63, 15, 39,69,61, 1017.0, 1013.5,5,5,22.8,23.8, 0, 1,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]

data_columns = ['MinTemp', 'MaxTemp', 'Rainfall', 'Evaporation', 'Sunshine','WindGustSpeed'
                , 'WindSpeed9am', 'WindSpeed3pm', 'Humidity9am', 'Humidity3pm','Pressure9am',
                'Pressure3pm','Cloud9am','Cloud3pm','Temp9am','Temp3pm','RainToday','RainTomorrow','Adelaide','Albany','Albury','AliceSprings','BadgerysCreek','Ballarat','Bendigo',
                'Brisbane','Cairns','Canberra','Cobar','CoffsHarbour','Dartmoor','Darwin','GoldCoast','Hobart','Katherine','Launceston','Melbourne',
                'MelbourneAirport','Mildura','Moree','MountGambier','MountGinini','Newcastle','Nhil','NorahHead','NorfolkIsland','Nuriootpa',
                'PearceRAAF','Penrith','Perth','PerthAirport','Portland','Richmond','Sale','SalmonGums','Sydney',
                'SydneyAirport','Townsville','Tuggeranong','Uluru','WaggaWagga','Walpole','Watsonia','Williamtown','Witchcliffe','Wollongong','Woomera',
                  'E','ENE','ESE','N','NE','NNE','NNW','NW','NoWind','S','SE','SSE','SSW','SW','W','WNW','WSW','E','ENE','ESE','N','NE','NNE',
                'NNW','NW','NoWind','S','SE','SSE','SSW','SW','W','WNW','WSW','E','ENE','ESE','N','NE','NNE','NNW','NW',
                'NoWind','S','SE','SSE','SSW','SW','W','WNW','WSW']


new_df = pd.DataFrame([new_data_rain_1,new_data_rain_2,new_data_rain_3,new_data_no_rain_1,new_data_no_rain_2,new_data_no_rain_3,new_data_rain_bris_1,new_data_rain_bris_2,new_data_rain_bris_3], columns= data_columns)

new_df

"""## Scaling the Data"""

# Using the same standard scaler used in training for consistency
new_data = get_loader(new_df, 9, 'Test', 3, scaler)

for i, (x_batch, y_batch) in enumerate(new_data):
    #if i >= 3:  # Stop after 3 iterations
        #break
    print(f"Batch {i+1}")
    print("X_batch (input features):", x_batch.shape)
    print("Y_batch (targets):", y_batch.shape)
    print("\n")

"""## Evaluating on New Data"""

model = Model(INPUT_SIZE, HIDDEN_DIM, OUTPUT_DIM, NUM_LAYERS, MODEL_TYPE).to(device)

EPOCH = 90

model_path = get_model_name(f'{MODEL_TYPE}_{NUM_LAYERS}layers', BATCH_SIZE, LEARNING_RATE, (NUM_EPOCHS-1))
state = torch.load(model_path)
model.load_state_dict(state)

criterion = nn.BCEWithLogitsLoss()

# Turn on evaluation mode of the model to disable dropout layers and other training-specific layers
model.eval()

predictions = get_accuracy(model, new_data, criterion, mode='prediction')

print(f'The predictions are: {predictions}')

"""## Debugging"""

if (test_data.columns.all() == new_df.columns.all()):
  print("true")
else:
  print("False")